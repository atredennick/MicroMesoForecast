4 + 4
test = 4
test+4
library(boot)#
#
# get track data#
infile= "PSSP_buf5_dorm2.csv"#
D=read.csv(infile)#
D=subset(D,year<=57)
?pairs
infile = "climeData.csv"
# get datafilesinfile = "perturbationresults.csv"# read the datafiledat = read.csv(infile)attach(dat)# creating summed elasticity and contribution values.EmuF = EmuF1 + EmuF2EmuS = EmuS1 + EmuS2EsF = abs((EsF1 + EsF2))EsS = abs((EsS1 + EsS2))Tsigma = abs(EsF + EsS)Tmu = EmuF + EmuSdenom = abs(EmuF) + abs(EmuS) + abs(EsF) + abs(EsS)relvarF = EsF/denomrelvarS = EsS/denomrelvarT = (EsF + EsS)/denomrelmeF = EmuF/denomrelmeS = EmuS/denomrelmeT = (EmuF + EmuS)/denom
startDir = "smb://geo.jql.usu.edu/adler0/idahochart/lifetables/polys/Species/Hesperostipa comata"#startDir = "/Volumes/adler0/idahochart/lifetables/polys/Species/Hesperostipa comata"#startDir="H:\\idahochart\\lifetables\\polys\\Species\\Pseudoroegneria spicata"outFile = "~/Desktop.assign_genetsHECO.csv"#outFile="H:\\idahochart\\ipm\\assign_genets.csv"setwd(startDir)library(maptools)library(sp)dat=NULLpdf("~/Desktop/HECOgenets.pdf",height=8,width=8)par(mfrow=c(2,2))## making a list of all the quadrat filesquadList=list.files(pattern="^Q")## looping through the quadrat files.for(iQ in quadList){## getting only the year files with .shp endings  yrFiles=list.files(iQ,pattern=".shp")## making a file name that includes the quadrat number and the year.  filename=paste(iQ,"\\",yrFiles[1],sep="")## pulling off only the year from the file name.  year=as.numeric(substring(filename,nchar(filename)-5,nchar(filename)-4))  ## reading in the shape data for the quadrat in the first year (see file
name).  shapes=readShapePoly(filename)  ## plot the shape data  plot(shapes)## plot the x-y coordinates of the data as points.  plot(shapes$x,shapes$y,pch=".",xlab="",ylab="",xaxt="n",yaxt="n",main=filename)## overlay the Species ID on the points plotted above.  text(shapes$x,shapes$y,as.character(shapes$SP_ID),col="black",cex=0.75)    tmp=data.frame(cbind("SP_ID"=as.character(shapes$SP_ID),"x"=shapes$x,"y"=shapes$y))  tmp$quad=iQ  tmp$year=year  dat=rbind(dat,tmp)## doing the same as above for the second year of the quadrat.   filename=paste(iQ,"\\",yrFiles[2],sep="")  year=as.numeric(substring(filename,nchar(filename)-5,nchar(filename)-4))  shapes=readShapePoly(filename)  plot(shapes)  plot(shapes$x,shapes$y,pch=".",xlab="",ylab="",xaxt="n",yaxt="n",main=filename)  text(shapes$x,shapes$y,as.character(shapes$SP_ID),col="black",cex=0.75) }dev.off()dat=dat[,c("quad","year","OBJECTID","x","y")]write.table(dat,outFile,row.names=F,sep=",")
outFile
dat
getwd()
startDir = "/Volumes/adler0/idahochart/lifetables/polys/Species/Hesperostipa comata"
#startDir="H:\\idahochart\\lifetables\\polys\\Species\\Pseudoroegneria spicata"outFile = "~/Desktop.assign_genetsHECO.csv"#outFile="H:\\idahochart\\ipm\\assign_genets.csv"setwd(startDir)library(maptools)library(sp)dat=NULLpdf("~/Desktop/HECOgenets.pdf",height=8,width=8)par(mfrow=c(2,2))## making a list of all the quadrat filesquadList=list.files(pattern="^Q")## looping through the quadrat files.for(iQ in quadList){## getting only the year files with .shp endings  yrFiles=list.files(iQ,pattern=".shp")## making a file name that includes the quadrat number and the year.  filename=paste(iQ,"\\",yrFiles[1],sep="")## pulling off only the year from the file name.  year=as.numeric(substring(filename,nchar(filename)-5,nchar(filename)-4))  ## reading in the shape data for the quadrat in the first year (see filename).  shapes=readShapePoly(filename)  ## plot the shape data  plot(shapes)## plot the x-y coordinates of the data as points.  plot(shapes$x,shapes$y,pch=".",xlab="",ylab="",xaxt
="n",yaxt="n",main=filename)## overlay the Species ID on the points plotted above.  text(shapes$x,shapes$y,as.character(shapes$SP_ID),col="black",cex=0.75)    tmp=data.frame(cbind("SP_ID"=as.character(shapes$SP_ID),"x"=shapes$x,"y"=shapes$y))  tmp$quad=iQ  tmp$year=year  dat=rbind(dat,tmp)## doing the same as above for the second year of the quadrat.   filename=paste(iQ,"\\",yrFiles[2],sep="")  year=as.numeric(substring(filename,nchar(filename)-5,nchar(filename)-4))  shapes=readShapePoly(filename)  plot(shapes)  plot(shapes$x,shapes$y,pch=".",xlab="",ylab="",xaxt="n",yaxt="n",main=filename)  text(shapes$x,shapes$y,as.character(shapes$SP_ID),col="black",cex=0.75) }dev.off()dat=dat[,c("quad","year","OBJECTID","x","y")]write.table(dat,outFile,row.names=F,sep=",")
getwd()
#startDir = "H://idahochart//lifetables//polys//Species//Artemisia tripartita"startDir = "/Volumes/adler0/idahochart/lifetables/polys/Species/Artemisia tripartita"#startDir="H:\\idahochart\\lifetables\\polys\\Species\\Pseudoroegneria spicata"#outFile = "assign_genetsHECO.csv"outFile="/Users/Harmony/Documents/ipm/ARTR/assign_genets.csv"setwd(startDir)library(maptools)library(sp)dat=NULLpdf("/Users/Harmony/Documents/ipm/ARTR/ARTRgenets.pdf",height=8,width=8)par(mfrow=c(2,2))## making a list of all the quadrat filesquadList=list.files(pattern="^Q")## looping through the quadrat files.for(iQ in quadList){## getting only the year files with .shp endings  yrFiles=list.files(iQ,pattern=".shp")  if(length(yrFiles)>0){    ## making a file name that includes the quadrat number and the year.      filename=paste(iQ,"/",yrFiles[1],sep="")    ## pulling off only the year from the file name.      year=as.numeric(substring(filename,nchar(filename)-5,nchar(filename)-4))    ## reading in the shap
e data for the quadrat in the first year (see filename).      shapes=readShapePoly(filename)    ## plot the shape data      plot(shapes,xlim=c(0,100),ylim=c(0,100))    ## plot the x-y coordinates of the data as points.      plot(shapes$x,shapes$y,pch=".",xlab="",ylab="",xaxt="n",yaxt="n",xlim=c(0,100),ylim=c(0,100),main=filename)    ## overlay the Species ID on the points plotted above.      text(shapes$x,shapes$y,as.character(shapes$SP_ID),col="black",cex=0.75)      tmp=data.frame(cbind("SP_ID"=as.character(shapes$SP_ID),"x"=shapes$x,"y"=shapes$y))      tmp$quad=iQ      tmp$year=year      dat=rbind(dat,tmp)  }  ## doing the same as above for the second year of the quadrat.  if(length(yrFiles) > 1) {    filename=paste(iQ,"/",yrFiles[2],sep="")    year=as.numeric(substring(filename,nchar(filename)-5,nchar(filename)-4))    shapes=readShapePoly(filename)    plot(shapes,xlim=c(0,100),ylim=c(0,100))    plot(shapes$x,shapes$y,pch=".",xlab="",ylab="",xaxt="n",yaxt="n",,xlim=c(0,100),ylim=c(0,
100),main=filename)    text(shapes$x,shapes$y,as.character(shapes$SP_ID),col="black",cex=0.75)  }}dev.off()dat=dat[,c("quad","year","SP_ID","x","y")]write.table(dat,outFile,row.names=F,sep=",")
#startDir = "H://idahochart//lifetables//polys//Species//Artemisia tripartita"startDir = "/Volumes/adler0/idahochart/lifetables/polys/Species/Artemisia tripartita"#startDir="H:\\idahochart\\lifetables\\polys\\Species\\Pseudoroegneria spicata"#outFile = "assign_genetsHECO.csv"outFile="/Users/Harmony/Documents/ipm/ARTR/assign_genets.csv"setwd(startDir)library(maptools)library(sp)dat=NULLpdf("/Users/Harmony/Documents/ipm/ARTR/ARTRgenets.pdf",height=8,width=8)par(mfrow=c(2,2))## making a list of all the quadrat filesquadList=list.files(pattern="^Q")## looping through the quadrat files.for(iQ in quadList){## getting only the year files with .shp endings  yrFiles=list.files(iQ,pattern=".shp")  if(length(yrFiles)>0){    ## making a file name that includes the quadrat number and the year.      filename=paste(iQ,"/",yrFiles[1],sep="")    ## pulling off only the year from the file name.      year=as.numeric(substring(filename,nchar(filename)-5,nchar(filename)-4))    ## reading in the shap
e data for the quadrat in the first year (see filename).      shapes=readShapePoly(filename)    ## plot the shape data      plot(shapes,xlim=c(0,100),ylim=c(0,100))    ## plot the x-y coordinates of the data as points.      plot(shapes$x,shapes$y,pch=".",xlab="",ylab="",xaxt="n",yaxt="n",xlim=c(0,100),ylim=c(0,100),main=filename)    ## overlay the Species ID on the points plotted above.      text(shapes$x,shapes$y,as.character(shapes$SP_ID),col="black",cex=0.75)      tmp=data.frame(cbind("SP_ID"=as.character(shapes$SP_ID),"x"=shapes$x,"y"=shapes$y))      tmp$quad=iQ      tmp$year=year      dat=rbind(dat,tmp)  }  ## doing the same as above for the second year of the quadrat.  if(length(yrFiles) > 1) {    filename=paste(iQ,"/",yrFiles[2],sep="")    year=as.numeric(substring(filename,nchar(filename)-5,nchar(filename)-4))    shapes=readShapePoly(filename)    plot(shapes,xlim=c(0,100),ylim=c(0,100))    plot(shapes$x,shapes$y,pch=".",xlab="",ylab="",xaxt="n",yaxt="n",,xlim=c(0,100),ylim=c(0,
100),main=filename)    text(shapes$x,shapes$y,as.character(shapes$SP_ID),col="black",cex=0.75)  }}dev.off()dat=dat[,c("quad","year","SP_ID","x","y")]write.table(dat,outFile,row.names=F,sep=",")
?seq
?locator
# This script tracks the identity of polygons in quadrats over time# It assumes polygon holes are correctly flagged# Change handling of missing vs. dormant yrs ???maxDorm=2maxArea=10000 # 1 m^2edgeDist=5minCoord=0maxCoord=100#sppShapes="h://idahochart//lifetables//polys//Species//Artemisia tripartita/"sppShapes = "/Volumes/adler0/idahochart/lifetables/polys/Species/Artemisia tripartita"#sppBuffers="h://idahochart//lifetables//polys//Species//Artemisia tripartita buf5//"sppBuffers="/Volumes/adler0/idahochart/lifetables/polys/Species/Artemisia tripartita buf5"#outfile="h://HarmonyData//IPM//ARTR_buf5_dorm2.csv"outfile = "/Users/Harmony/ipm/ARTR/Data/"#genetFile="h://HarmonyData//IPM//ARTR//AssignGenets//assign_genetsARTR.csv"genetFile = "/Users/Harmony/ipm/ARTR/AssignGenets/assign_genetsARTR.csv"library(maptools)library(sp)library(gpclib)
getwd()
# This script tracks the identity of polygons in quadrats over time# It assumes polygon holes are correctly flagged# Change handling of missing vs. dormant yrs ???maxDorm=2maxArea=10000 # 1 m^2edgeDist=5minCoord=0maxCoord=100#sppShapes="h://idahochart//lifetables//polys//Species//Artemisia tripartita/"sppShapes = "/Volumes/adler0/idahochart/lifetables/polys/Species/Artemisia tripartita"#sppBuffers="h://idahochart//lifetables//polys//Species//Artemisia tripartita buf5//"sppBuffers="/Volumes/adler0/idahochart/lifetables/polys/Species/Artemisia tripartita buf5"#outfile="h://HarmonyData//IPM//ARTR_buf5_dorm2.csv"outfile = "/Users/Harmony/ipm/ARTR/Data/"#genetFile="h://HarmonyData//IPM//ARTR//AssignGenets//assign_genetsARTR.csv"genetFile = "/Users/Harmony/ipm/ARTR/AssignGenets/assign_genetsARTR.csv"library(maptools)library(sp)library(gpclib)
#---------------------------------------------------------getOverlap=function(x,y){# function to calculate overlap between 2 polygons# x and y are SpatialPolygons lists of length 1 (1 feature)   N1=length(x@Polygons)   N2=length(y@Polygons)   sumArea=0   for(ii in 1:N1){     for(jj in 1:N2){        p1=x@Polygons[[ii]]@coords        p2=y@Polygons[[jj]]@coords        hole1=ifelse(x@Polygons[[ii]]@hole==T,-1,1)        hole2=ifelse(y@Polygons[[jj]]@hole==T,-1,1)        p1=as(p1,"gpc.poly")        p2=as(p2,"gpc.poly")        # intersect polygons        tmp=intersect(p1,p2)        sumArea=sumArea+area.poly(tmp)*hole1*hole2     } # next jj   } # next ii   sumArea}#---------------------------------------------------------checkEdge=function(x,edgeDist,minCoord,maxCoord){# check whether polygon is close to quadrat edge# x is a SpatialPolygons list object of length 1 (1 feature)   N1=length(x@Polygons)   out=F   ii=1   while(ii<=N1 & out==F){        p1=x@Polygons[[ii]]@coords        if(
min(p1)<=(minCoord+edgeDist) |  max(p1)>=(maxCoord-edgeDist)) out=T        ii=ii+1   } # next ii   out}#---------------------------------------------------------yr1genets=read.csv(genetFile)
#sppShapes="h://idahochart//lifetables//polys//Species//Artemisia tripartita/"sppShapes = "/Volumes/adler0/idahochart/lifetables/polys/Species/Artemisia tripartita"#sppBuffers="h://idahochart//lifetables//polys//Species//Artemisia tripartita buf5//"sppBuffers="/Volumes/adler0/idahochart/lifetables/polys/Species/Artemisia tripartita buf5"#outfile="h://HarmonyData//IPM//ARTR_buf5_dorm2.csv"outfile = "/Users/Harmony/Documents/ipm/ARTR/Data/"#genetFile="h://HarmonyData//IPM//ARTR//AssignGenets//assign_genetsARTR.csv"genetFile = "/Users/Harmony/Documents/ipm/ARTR/AssignGenets/assign_genetsARTR.csv"
library(maptools)library(sp)library(gpclib)#---------------------------------------------------------getOverlap=function(x,y){# function to calculate overlap between 2 polygons# x and y are SpatialPolygons lists of length 1 (1 feature)   N1=length(x@Polygons)   N2=length(y@Polygons)   sumArea=0   for(ii in 1:N1){     for(jj in 1:N2){        p1=x@Polygons[[ii]]@coords        p2=y@Polygons[[jj]]@coords        hole1=ifelse(x@Polygons[[ii]]@hole==T,-1,1)        hole2=ifelse(y@Polygons[[jj]]@hole==T,-1,1)        p1=as(p1,"gpc.poly")        p2=as(p2,"gpc.poly")        # intersect polygons        tmp=intersect(p1,p2)        sumArea=sumArea+area.poly(tmp)*hole1*hole2     } # next jj   } # next ii   sumArea}#---------------------------------------------------------checkEdge=function(x,edgeDist,minCoord,maxCoord){# check whether polygon is close to quadrat edge# x is a SpatialPolygons list object of length 1 (1 feature)   N1=length(x@Polygons)   out=F   ii=1   while(ii<=N1 & out==F){
        p1=x@Polygons[[ii]]@coords        if(min(p1)<=(minCoord+edgeDist) |  max(p1)>=(maxCoord-edgeDist)) out=T        ii=ii+1   } # next ii   out}#---------------------------------------------------------yr1genets=read.csv(genetFile)
yr1genets=yr1genets[,c("quad","year","SP_ID","GenID")]#loop through quadratsquadFiles=list.files(path=sppShapes,pattern="q*")firstQuad=Tfor(qI in 1:length(quadFiles)){  quad=quadFiles[qI]  rawDir=paste(sppShapes,quad,sep="")  bufDir=paste(sppBuffers,quad,sep="")  # load all polygons in the quad into one list of SpatialPolygonsDataFrame  # with a new year attribute  #loop through years in quadrat  yrFiles=list.files(path=rawDir,pattern=".shp")
if(length(yrFiles>0)){    begin=T    for(yrI in 1:length(yrFiles)){      if(begin==T){        #original data        infile=paste(rawDir,"//",yrFiles[yrI],sep="")        rawD=readShapePoly(infile)        rawD@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        rawD@data$quad=as.character(quad)        rawD@data=rawD@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        #buffered data        tmp=sub("-","_",yrFiles[yrI])        infile=paste(bufDir,"//",tmp,sep="")        bufD=readShapePoly(infile)        bufD@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        bufD@data$quad=as.character(quad)        bufD@data=bufD@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        begin=F      }else{        #original data        infile=paste(rawDir,"//",yrFiles[yrI],sep="")        tmp1=readShapePoly(infile)        tmp1@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))
    tmp1@data$quad=as.character(quad)        tmp1@data=tmp1@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        ID1=getSpPPolygonsIDSlots(rawD)        ID2=getSpPPolygonsIDSlots(tmp1)        ID2=as.character(as.numeric(ID2)+1+max(as.numeric(ID1)))        tmp2=spChFIDs(tmp1,ID2)        rawD=spRbind(rawD,tmp2)        rm(tmp1,tmp2)        #buffered data        tmp=sub("-","_",yrFiles[yrI])        infile=paste(bufDir,"//",tmp,sep="")        tmp1=readShapePoly(infile)        tmp1@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        tmp1@data$quad=as.character(quad)        tmp1@data=tmp1@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        ID1=getSpPPolygonsIDSlots(bufD)        ID2=getSpPPolygonsIDSlots(tmp1)        ID2=as.character(as.numeric(ID2)+1+max(as.numeric(ID1)))        tmp2=spChFIDs(tmp1,ID2)        bufD=spRbind(bufD,tmp2)        rm(tmp1,tmp2)      }  # end if    } # next yrI
    # join yr 1 genets    tmp=rawD@data    tmp$key=as.numeric(row.names(rawD@data))    tmp$SP_ID=as.character(tmp$SP_ID)    tmp=merge(tmp,yr1genets,all.x=T)    tmp=tmp[order(tmp$key),]    trackID=tmp$GenID    rm(tmp)    # create matrix of year lags    if(sum(bufD@data$year!=rawD@data$year)>0) stop("Raw and buffer data do not match")    year=bufD@data$year    dorm<-outer(year,year,"-")    dorm[dorm<1]<-NA    dorm[dorm>(1+maxDorm)]<-NA    dorm<-(dorm-1)*maxArea*-1    # create matrix of centroid distances (for tiebreaker)    xdiff<-outer(rawD@data$x,rawD@data$x,FUN="-")    ydiff<-outer(rawD@data$y,rawD@data$y,FUN="-")    dist<-sqrt(xdiff^2+ydiff^2)    rm(xdiff,ydiff)    # create matrix of polygons overlaps    if(dim(dorm)[1]>1){      overlap=dorm      overlap[is.na(overlap)==F]=-99      for(j in 1:(dim(overlap)[1]-1)){        for(k in (j+1):dim(overlap)[1]){            if(is.na(overlap[k,j])==F){              P1=rawD@polygons[[j]]              P2=bufD@polygons[[k]]
 overlap[k,j]=getOverlap(P1,P2)            }        } # next k      } # next j      overlap[overlap==0]=NA    }else{      overlap=0    }        # assign identities    track<-overlap+dorm    rowMax<-apply(track,1,max,na.rm=T)    rowMax<-matrix(rowMax,dim(track)[1],dim(track)[2])    track[track!=rowMax]<-NA    track<-(is.na(track)==F)    track[rawD$seedling=="Y",]<-F    # check for multiple parents    tmp=rowSums(track)    tmp2=which(tmp>1)    if(length(tmp2)>0){      for(j in 1:length(tmp2)){        tmp3=which(track[tmp2[j],]==T)        tmp4=which(dist[tmp2[j],tmp3]==min(dist[tmp2[j],tmp3]))        track[tmp2[j],]=F        track[tmp2[j],tmp3[tmp4]]=T      } # next j    } # end if    if(sum(rowSums(track)>1)) stop("Multiple parents")    isColonist<-ifelse(rowSums(track)==0,1,0)    survives<-1*(colSums(track)>0)    # add to output data table    age<-rep(NA,length(isColonist))    dormancy<-rep(NA,length(isColonist))    # trackID<-rep(NA,length(isColonist))  #assigned above
nearEdge<-rep(NA,length(isColonist))    firstYear<-rep(NA,length(isColonist))    trackN<-max(trackID,na.rm=T)        for(i in 1:length(isColonist)){       if(isColonist[i]==1)       {           if(is.na(trackID[i])){    # otherwise use existing ID             trackN<-trackN+1             trackID[i]<-trackN           }           age[i]<-1           dormancy[i]<-0           nearEdge[i]=checkEdge(rawD@polygons[[i]],edgeDist,minCoord,maxCoord)       }else{           tmp<-which(track[i,]==T)           delta<-dorm[i,tmp]/(-1*maxArea)+1           ifelse(delta>1,dormancy[i]<-(delta-1),dormancy[i]<-0)           age[i]<-age[tmp]+delta           trackID[i]<-trackID[tmp]           nearEdge[i]=checkEdge(rawD@polygons[[i]],edgeDist,minCoord,maxCoord)       }    }    out<-data.frame(cbind(rawD@data,age,survives,dormancy,trackID,nearEdge))    out=out[,c("quad","year","SP_ID","OBJECTID","species","seedling","area","x","y",      "age","survives","dormancy","trackID","nearEdge")]    #write to output
    if(firstQuad==T){        write.table(out,outfile,row.names=F,sep=",")        firstQuad=F    }else{       write.table(out,outfile,row.names=F,col.names=F,sep=",",append=T)    } # end if  } # end if length(yrFiles)  } #next quad
warnings()
rawDir
sppShapes
# This script tracks the identity of polygons in quadrats over time# It assumes polygon holes are correctly flagged# Change handling of missing vs. dormant yrs ???maxDorm=2maxArea=10000 # 1 m^2edgeDist=5minCoord=0maxCoord=100#sppShapes="h://idahochart//lifetables//polys//Species//Artemisia tripartita/"sppShapes = "/Volumes/adler0/idahochart/lifetables/polys/Species/Artemisia tripartita"#sppBuffers="h://idahochart//lifetables//polys//Species//Artemisia tripartita buf5//"sppBuffers="/Volumes/adler0/idahochart/lifetables/polys/Species/Artemisia tripartita buf5"#outfile="h://HarmonyData//IPM//ARTR_buf5_dorm2.csv"outfile = "/Users/Harmony/Documents/ipm/ARTR/Data/"#genetFile="h://HarmonyData//IPM//ARTR//AssignGenets//assign_genetsARTR.csv"genetFile = "/Users/Harmony/Documents/ipm/ARTR/AssignGenets/assign_genetsARTR.csv"library(maptools)library(sp)library(gpclib)#---------------------------------------------------------getOverlap=function(x,y){# function to calculate overlap between 2 p
olygons# x and y are SpatialPolygons lists of length 1 (1 feature)   N1=length(x@Polygons)   N2=length(y@Polygons)   sumArea=0   for(ii in 1:N1){     for(jj in 1:N2){        p1=x@Polygons[[ii]]@coords        p2=y@Polygons[[jj]]@coords        hole1=ifelse(x@Polygons[[ii]]@hole==T,-1,1)        hole2=ifelse(y@Polygons[[jj]]@hole==T,-1,1)        p1=as(p1,"gpc.poly")        p2=as(p2,"gpc.poly")        # intersect polygons        tmp=intersect(p1,p2)        sumArea=sumArea+area.poly(tmp)*hole1*hole2     } # next jj   } # next ii   sumArea}#---------------------------------------------------------checkEdge=function(x,edgeDist,minCoord,maxCoord){# check whether polygon is close to quadrat edge# x is a SpatialPolygons list object of length 1 (1 feature)   N1=length(x@Polygons)   out=F   ii=1   while(ii<=N1 & out==F){        p1=x@Polygons[[ii]]@coords        if(min(p1)<=(minCoord+edgeDist) |  max(p1)>=(maxCoord-edgeDist)) out=T        ii=ii+1   } # next ii   out}#--------------------
-------------------------------------yr1genets=read.csv(genetFile)yr1genets=yr1genets[,c("quad","year","SP_ID","GenID")]#loop through quadratsquadFiles=list.files(path=sppShapes,pattern="q*")firstQuad=Tfor(qI in 1:length(quadFiles)){  quad=quadFiles[qI]  rawDir=paste(sppShapes,quad,sep="")  bufDir=paste(sppBuffers,quad,sep="")  # load all polygons in the quad into one list of SpatialPolygonsDataFrame  # with a new year attribute  #loop through years in quadrat  yrFiles=list.files(path=rawDir,pattern=".shp")  if(length(yrFiles>0)){    begin=T    for(yrI in 1:length(yrFiles)){      if(begin==T){        #original data        infile=paste(rawDir,"/",yrFiles[yrI],sep="")        rawD=readShapePoly(infile)        rawD@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        rawD@data$quad=as.character(quad)        rawD@data=rawD@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        #buffered data        tmp=sub("-","_",yrFiles[yrI])
   infile=paste(bufDir,"/",tmp,sep="")        bufD=readShapePoly(infile)        bufD@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        bufD@data$quad=as.character(quad)        bufD@data=bufD@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        begin=F      }else{        #original data        infile=paste(rawDir,"/",yrFiles[yrI],sep="")        tmp1=readShapePoly(infile)        tmp1@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        tmp1@data$quad=as.character(quad)        tmp1@data=tmp1@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        ID1=getSpPPolygonsIDSlots(rawD)        ID2=getSpPPolygonsIDSlots(tmp1)        ID2=as.character(as.numeric(ID2)+1+max(as.numeric(ID1)))        tmp2=spChFIDs(tmp1,ID2)        rawD=spRbind(rawD,tmp2)        rm(tmp1,tmp2)        #buffered data        tmp=sub("-","_",yrFiles[yrI])        infile=paste(bufDir,"/",tmp,sep="")        tmp1=readSha
pePoly(infile)        tmp1@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        tmp1@data$quad=as.character(quad)        tmp1@data=tmp1@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        ID1=getSpPPolygonsIDSlots(bufD)        ID2=getSpPPolygonsIDSlots(tmp1)        ID2=as.character(as.numeric(ID2)+1+max(as.numeric(ID1)))        tmp2=spChFIDs(tmp1,ID2)        bufD=spRbind(bufD,tmp2)        rm(tmp1,tmp2)      }  # end if    } # next yrI        # join yr 1 genets    tmp=rawD@data    tmp$key=as.numeric(row.names(rawD@data))    tmp$SP_ID=as.character(tmp$SP_ID)    tmp=merge(tmp,yr1genets,all.x=T)    tmp=tmp[order(tmp$key),]    trackID=tmp$GenID    rm(tmp)    # create matrix of year lags    if(sum(bufD@data$year!=rawD@data$year)>0) stop("Raw and buffer data do not match")    year=bufD@data$year    dorm<-outer(year,year,"-")    dorm[dorm<1]<-NA    dorm[dorm>(1+maxDorm)]<-NA    dorm<-(dorm-1)*maxArea*-1    # create matrix of cent
roid distances (for tiebreaker)    xdiff<-outer(rawD@data$x,rawD@data$x,FUN="-")    ydiff<-outer(rawD@data$y,rawD@data$y,FUN="-")    dist<-sqrt(xdiff^2+ydiff^2)    rm(xdiff,ydiff)    # create matrix of polygons overlaps    if(dim(dorm)[1]>1){      overlap=dorm      overlap[is.na(overlap)==F]=-99      for(j in 1:(dim(overlap)[1]-1)){        for(k in (j+1):dim(overlap)[1]){            if(is.na(overlap[k,j])==F){              P1=rawD@polygons[[j]]              P2=bufD@polygons[[k]]              overlap[k,j]=getOverlap(P1,P2)            }        } # next k      } # next j      overlap[overlap==0]=NA    }else{      overlap=0    }        # assign identities    track<-overlap+dorm    rowMax<-apply(track,1,max,na.rm=T)    rowMax<-matrix(rowMax,dim(track)[1],dim(track)[2])    track[track!=rowMax]<-NA    track<-(is.na(track)==F)    track[rawD$seedling=="Y",]<-F    # check for multiple parents    tmp=rowSums(track)    tmp2=which(tmp>1)    if(length(tmp2)>0){      for(j in 1:length(tm
p2)){        tmp3=which(track[tmp2[j],]==T)        tmp4=which(dist[tmp2[j],tmp3]==min(dist[tmp2[j],tmp3]))        track[tmp2[j],]=F        track[tmp2[j],tmp3[tmp4]]=T      } # next j    } # end if    if(sum(rowSums(track)>1)) stop("Multiple parents")    isColonist<-ifelse(rowSums(track)==0,1,0)    survives<-1*(colSums(track)>0)    # add to output data table    age<-rep(NA,length(isColonist))    dormancy<-rep(NA,length(isColonist))    # trackID<-rep(NA,length(isColonist))  #assigned above    nearEdge<-rep(NA,length(isColonist))    firstYear<-rep(NA,length(isColonist))    trackN<-max(trackID,na.rm=T)        for(i in 1:length(isColonist)){       if(isColonist[i]==1)       {           if(is.na(trackID[i])){    # otherwise use existing ID             trackN<-trackN+1             trackID[i]<-trackN           }           age[i]<-1           dormancy[i]<-0           nearEdge[i]=checkEdge(rawD@polygons[[i]],edgeDist,minCoord,maxCoord)       }else{           tmp<-which(track[i,]==T)
       delta<-dorm[i,tmp]/(-1*maxArea)+1           ifelse(delta>1,dormancy[i]<-(delta-1),dormancy[i]<-0)           age[i]<-age[tmp]+delta           trackID[i]<-trackID[tmp]           nearEdge[i]=checkEdge(rawD@polygons[[i]],edgeDist,minCoord,maxCoord)       }    }    out<-data.frame(cbind(rawD@data,age,survives,dormancy,trackID,nearEdge))    out=out[,c("quad","year","SP_ID","OBJECTID","species","seedling","area","x","y",      "age","survives","dormancy","trackID","nearEdge")]    #write to output    if(firstQuad==T){        write.table(out,outfile,row.names=F,sep=",")        firstQuad=F    }else{       write.table(out,outfile,row.names=F,col.names=F,sep=",",append=T)    } # end if  } # end if length(yrFiles)  } #next quad
warnings()
rawDir
quad
quadFiles
# This script tracks the identity of polygons in quadrats over time# It assumes polygon holes are correctly flagged# Change handling of missing vs. dormant yrs ???maxDorm=2maxArea=10000 # 1 m^2edgeDist=5minCoord=0maxCoord=100#sppShapes="h://idahochart//lifetables//polys//Species//Artemisia tripartita/"sppShapes = "/Volumes/adler0/idahochart/lifetables/polys/Species/Artemisia tripartita/"#sppBuffers="h://idahochart//lifetables//polys//Species//Artemisia tripartita buf5//"sppBuffers="/Volumes/adler0/idahochart/lifetables/polys/Species/Artemisia tripartita buf5/"#outfile="h://HarmonyData//IPM//ARTR_buf5_dorm2.csv"outfile = "/Users/Harmony/Documents/ipm/ARTR/Data/"#genetFile="h://HarmonyData//IPM//ARTR//AssignGenets//assign_genetsARTR.csv"genetFile = "/Users/Harmony/Documents/ipm/ARTR/AssignGenets/assign_genetsARTR.csv"library(maptools)library(sp)library(gpclib)#---------------------------------------------------------getOverlap=function(x,y){# function to calculate overlap between 2
 polygons# x and y are SpatialPolygons lists of length 1 (1 feature)   N1=length(x@Polygons)   N2=length(y@Polygons)   sumArea=0   for(ii in 1:N1){     for(jj in 1:N2){        p1=x@Polygons[[ii]]@coords        p2=y@Polygons[[jj]]@coords        hole1=ifelse(x@Polygons[[ii]]@hole==T,-1,1)        hole2=ifelse(y@Polygons[[jj]]@hole==T,-1,1)        p1=as(p1,"gpc.poly")        p2=as(p2,"gpc.poly")        # intersect polygons        tmp=intersect(p1,p2)        sumArea=sumArea+area.poly(tmp)*hole1*hole2     } # next jj   } # next ii   sumArea}#---------------------------------------------------------checkEdge=function(x,edgeDist,minCoord,maxCoord){# check whether polygon is close to quadrat edge# x is a SpatialPolygons list object of length 1 (1 feature)   N1=length(x@Polygons)   out=F   ii=1   while(ii<=N1 & out==F){        p1=x@Polygons[[ii]]@coords        if(min(p1)<=(minCoord+edgeDist) |  max(p1)>=(maxCoord-edgeDist)) out=T        ii=ii+1   } # next ii   out}#------------------
---------------------------------------yr1genets=read.csv(genetFile)yr1genets=yr1genets[,c("quad","year","SP_ID","GenID")]#loop through quadratsquadFiles=list.files(path=sppShapes,pattern="q*")firstQuad=Tfor(qI in 1:length(quadFiles)){  quad=quadFiles[qI]  rawDir=paste(sppShapes,quad,sep="")  bufDir=paste(sppBuffers,quad,sep="")  # load all polygons in the quad into one list of SpatialPolygonsDataFrame  # with a new year attribute  #loop through years in quadrat  yrFiles=list.files(path=rawDir,pattern=".shp")  if(length(yrFiles>0)){    begin=T    for(yrI in 1:length(yrFiles)){      if(begin==T){        #original data        infile=paste(rawDir,"/",yrFiles[yrI],sep="")        rawD=readShapePoly(infile)        rawD@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        rawD@data$quad=as.character(quad)        rawD@data=rawD@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        #buffered data        tmp=sub("-","_",yrFiles[yrI])
     infile=paste(bufDir,"/",tmp,sep="")        bufD=readShapePoly(infile)        bufD@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        bufD@data$quad=as.character(quad)        bufD@data=bufD@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        begin=F      }else{        #original data        infile=paste(rawDir,"/",yrFiles[yrI],sep="")        tmp1=readShapePoly(infile)        tmp1@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        tmp1@data$quad=as.character(quad)        tmp1@data=tmp1@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        ID1=getSpPPolygonsIDSlots(rawD)        ID2=getSpPPolygonsIDSlots(tmp1)        ID2=as.character(as.numeric(ID2)+1+max(as.numeric(ID1)))        tmp2=spChFIDs(tmp1,ID2)        rawD=spRbind(rawD,tmp2)        rm(tmp1,tmp2)        #buffered data        tmp=sub("-","_",yrFiles[yrI])        infile=paste(bufDir,"/",tmp,sep="")        tmp1=readS
hapePoly(infile)        tmp1@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        tmp1@data$quad=as.character(quad)        tmp1@data=tmp1@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        ID1=getSpPPolygonsIDSlots(bufD)        ID2=getSpPPolygonsIDSlots(tmp1)        ID2=as.character(as.numeric(ID2)+1+max(as.numeric(ID1)))        tmp2=spChFIDs(tmp1,ID2)        bufD=spRbind(bufD,tmp2)        rm(tmp1,tmp2)      }  # end if    } # next yrI        # join yr 1 genets    tmp=rawD@data    tmp$key=as.numeric(row.names(rawD@data))    tmp$SP_ID=as.character(tmp$SP_ID)    tmp=merge(tmp,yr1genets,all.x=T)    tmp=tmp[order(tmp$key),]    trackID=tmp$GenID    rm(tmp)    # create matrix of year lags    if(sum(bufD@data$year!=rawD@data$year)>0) stop("Raw and buffer data do not match")    year=bufD@data$year    dorm<-outer(year,year,"-")    dorm[dorm<1]<-NA    dorm[dorm>(1+maxDorm)]<-NA    dorm<-(dorm-1)*maxArea*-1    # create matrix of ce
ntroid distances (for tiebreaker)    xdiff<-outer(rawD@data$x,rawD@data$x,FUN="-")    ydiff<-outer(rawD@data$y,rawD@data$y,FUN="-")    dist<-sqrt(xdiff^2+ydiff^2)    rm(xdiff,ydiff)    # create matrix of polygons overlaps    if(dim(dorm)[1]>1){      overlap=dorm      overlap[is.na(overlap)==F]=-99      for(j in 1:(dim(overlap)[1]-1)){        for(k in (j+1):dim(overlap)[1]){            if(is.na(overlap[k,j])==F){              P1=rawD@polygons[[j]]              P2=bufD@polygons[[k]]              overlap[k,j]=getOverlap(P1,P2)            }        } # next k      } # next j      overlap[overlap==0]=NA    }else{      overlap=0    }        # assign identities    track<-overlap+dorm    rowMax<-apply(track,1,max,na.rm=T)    rowMax<-matrix(rowMax,dim(track)[1],dim(track)[2])    track[track!=rowMax]<-NA    track<-(is.na(track)==F)    track[rawD$seedling=="Y",]<-F    # check for multiple parents    tmp=rowSums(track)    tmp2=which(tmp>1)    if(length(tmp2)>0){      for(j in 1:length(
tmp2)){        tmp3=which(track[tmp2[j],]==T)        tmp4=which(dist[tmp2[j],tmp3]==min(dist[tmp2[j],tmp3]))        track[tmp2[j],]=F        track[tmp2[j],tmp3[tmp4]]=T      } # next j    } # end if    if(sum(rowSums(track)>1)) stop("Multiple parents")    isColonist<-ifelse(rowSums(track)==0,1,0)    survives<-1*(colSums(track)>0)    # add to output data table    age<-rep(NA,length(isColonist))    dormancy<-rep(NA,length(isColonist))    # trackID<-rep(NA,length(isColonist))  #assigned above    nearEdge<-rep(NA,length(isColonist))    firstYear<-rep(NA,length(isColonist))    trackN<-max(trackID,na.rm=T)        for(i in 1:length(isColonist)){       if(isColonist[i]==1)       {           if(is.na(trackID[i])){    # otherwise use existing ID             trackN<-trackN+1             trackID[i]<-trackN           }           age[i]<-1           dormancy[i]<-0           nearEdge[i]=checkEdge(rawD@polygons[[i]],edgeDist,minCoord,maxCoord)       }else{           tmp<-which(track[i,]==T)
         delta<-dorm[i,tmp]/(-1*maxArea)+1           ifelse(delta>1,dormancy[i]<-(delta-1),dormancy[i]<-0)           age[i]<-age[tmp]+delta           trackID[i]<-trackID[tmp]           nearEdge[i]=checkEdge(rawD@polygons[[i]],edgeDist,minCoord,maxCoord)       }    }    out<-data.frame(cbind(rawD@data,age,survives,dormancy,trackID,nearEdge))    out=out[,c("quad","year","SP_ID","OBJECTID","species","seedling","area","x","y",      "age","survives","dormancy","trackID","nearEdge")]    #write to output    if(firstQuad==T){        write.table(out,outfile,row.names=F,sep=",")        firstQuad=F    }else{       write.table(out,outfile,row.names=F,col.names=F,sep=",",append=T)    } # end if  } # end if length(yrFiles)  } #next quad
warnings()
getwd()
quad
rawDir
bufDir
YrFiles
tmp
# This script tracks the identity of polygons in quadrats over time# It assumes polygon holes are correctly flagged# Change handling of missing vs. dormant yrs ???maxDorm=2maxArea=10000 # 1 m^2edgeDist=5minCoord=0maxCoord=100#sppShapes="h://idahochart//lifetables//polys//Species//Artemisia tripartita/"sppShapes = "/Volumes/adler0/idahochart/lifetables/polys/Species/Artemisia tripartita/"#sppBuffers="h://idahochart//lifetables//polys//Species//Artemisia tripartita buf5//"sppBuffers="/Volumes/adler0/idahochart/lifetables/polys/Species/Artemisia tripartita buf5/"#outfile="h://HarmonyData//IPM//ARTR_buf5_dorm2.csv"outfile = "/Users/Harmony/Documents/ipm/ARTR/Data/"#genetFile="h://HarmonyData//IPM//ARTR//AssignGenets//assign_genetsARTR.csv"genetFile = "/Users/Harmony/Documents/ipm/ARTR/AssignGenets/assign_genetsARTR.csv"library(maptools)library(sp)library(gpclib)#---------------------------------------------------------getOverlap=function(x,y){# function to calculate overlap between 2
 polygons# x and y are SpatialPolygons lists of length 1 (1 feature)   N1=length(x@Polygons)   N2=length(y@Polygons)   sumArea=0   for(ii in 1:N1){     for(jj in 1:N2){        p1=x@Polygons[[ii]]@coords        p2=y@Polygons[[jj]]@coords        hole1=ifelse(x@Polygons[[ii]]@hole==T,-1,1)        hole2=ifelse(y@Polygons[[jj]]@hole==T,-1,1)        p1=as(p1,"gpc.poly")        p2=as(p2,"gpc.poly")        # intersect polygons        tmp=intersect(p1,p2)        sumArea=sumArea+area.poly(tmp)*hole1*hole2     } # next jj   } # next ii   sumArea}#---------------------------------------------------------checkEdge=function(x,edgeDist,minCoord,maxCoord){# check whether polygon is close to quadrat edge# x is a SpatialPolygons list object of length 1 (1 feature)   N1=length(x@Polygons)   out=F   ii=1   while(ii<=N1 & out==F){        p1=x@Polygons[[ii]]@coords        if(min(p1)<=(minCoord+edgeDist) |  max(p1)>=(maxCoord-edgeDist)) out=T        ii=ii+1   } # next ii   out}#------------------
---------------------------------------yr1genets=read.csv(genetFile)yr1genets=yr1genets[,c("quad","year","SP_ID","GenID")]#loop through quadratsquadFiles=list.files(path=sppShapes,pattern="q*")firstQuad=Tfor(qI in 1:length(quadFiles)){  quad=quadFiles[qI]  rawDir=paste(sppShapes,quad,sep="")  bufDir=paste(sppBuffers,quad,sep="")  # load all polygons in the quad into one list of SpatialPolygonsDataFrame  # with a new year attribute  #loop through years in quadrat  yrFiles=list.files(path=rawDir,pattern=".shp")  if(length(yrFiles>0)){    begin=T    for(yrI in 1:length(yrFiles)){      if(begin==T){        #original data        infile=paste(rawDir,"/",yrFiles[yrI],sep="")        rawD=readShapePoly(infile)        rawD@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        rawD@data$quad=as.character(quad)        rawD@data=rawD@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        #buffered data        tmp=sub("-","_",yrFiles[yrI])
     infile=paste(bufDir,"/",tmp,sep="")        bufD=readShapePoly(infile)        bufD@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        bufD@data$quad=as.character(quad)        bufD@data=bufD@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        begin=F      }else{        #original data        infile=paste(rawDir,"/",yrFiles[yrI],sep="")        tmp1=readShapePoly(infile)        tmp1@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        tmp1@data$quad=as.character(quad)        tmp1@data=tmp1@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        ID1=getSpPPolygonsIDSlots(rawD)        ID2=getSpPPolygonsIDSlots(tmp1)        ID2=as.character(as.numeric(ID2)+1+max(as.numeric(ID1)))        tmp2=spChFIDs(tmp1,ID2)        rawD=spRbind(rawD,tmp2)        rm(tmp1,tmp2)        #buffered data        tmp=sub("-","_",yrFiles[yrI])        infile=paste(bufDir,"/",tmp,sep="")        tmp1=readS
hapePoly(infile)        tmp1@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        tmp1@data$quad=as.character(quad)        tmp1@data=tmp1@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        ID1=getSpPPolygonsIDSlots(bufD)        ID2=getSpPPolygonsIDSlots(tmp1)        ID2=as.character(as.numeric(ID2)+1+max(as.numeric(ID1)))        tmp2=spChFIDs(tmp1,ID2)        bufD=spRbind(bufD,tmp2)        rm(tmp1,tmp2)      }  # end if    } # next yrI        # join yr 1 genets    tmp=rawD@data    tmp$key=as.numeric(row.names(rawD@data))    tmp$SP_ID=as.character(tmp$SP_ID)    tmp=merge(tmp,yr1genets,all.x=T)    tmp=tmp[order(tmp$key),]    trackID=tmp$GenID    rm(tmp)    # create matrix of year lags    if(sum(bufD@data$year!=rawD@data$year)>0) stop("Raw and buffer data do not match")    year=bufD@data$year    dorm<-outer(year,year,"-")    dorm[dorm<1]<-NA    dorm[dorm>(1+maxDorm)]<-NA    dorm<-(dorm-1)*maxArea*-1    # create matrix of ce
ntroid distances (for tiebreaker)    xdiff<-outer(rawD@data$x,rawD@data$x,FUN="-")    ydiff<-outer(rawD@data$y,rawD@data$y,FUN="-")    dist<-sqrt(xdiff^2+ydiff^2)    rm(xdiff,ydiff)    # create matrix of polygons overlaps    if(dim(dorm)[1]>1){      overlap=dorm      overlap[is.na(overlap)==F]=-99      for(j in 1:(dim(overlap)[1]-1)){        for(k in (j+1):dim(overlap)[1]){            if(is.na(overlap[k,j])==F){              P1=rawD@polygons[[j]]              P2=bufD@polygons[[k]]              overlap[k,j]=getOverlap(P1,P2)            }        } # next k      } # next j      overlap[overlap==0]=NA    }else{      overlap=0    }        # assign identities    track<-overlap+dorm    rowMax<-apply(track,1,max,na.rm=T)    rowMax<-matrix(rowMax,dim(track)[1],dim(track)[2])    track[track!=rowMax]<-NA    track<-(is.na(track)==F)    track[rawD$seedling=="Y",]<-F    # check for multiple parents    tmp=rowSums(track)    tmp2=which(tmp>1)    if(length(tmp2)>0){      for(j in 1:length(
tmp2)){        tmp3=which(track[tmp2[j],]==T)        tmp4=which(dist[tmp2[j],tmp3]==min(dist[tmp2[j],tmp3]))        track[tmp2[j],]=F        track[tmp2[j],tmp3[tmp4]]=T      } # next j    } # end if    if(sum(rowSums(track)>1)) stop("Multiple parents")    isColonist<-ifelse(rowSums(track)==0,1,0)    survives<-1*(colSums(track)>0)    # add to output data table    age<-rep(NA,length(isColonist))    dormancy<-rep(NA,length(isColonist))    # trackID<-rep(NA,length(isColonist))  #assigned above    nearEdge<-rep(NA,length(isColonist))    firstYear<-rep(NA,length(isColonist))    trackN<-max(trackID,na.rm=T)        for(i in 1:length(isColonist)){       if(isColonist[i]==1)       {           if(is.na(trackID[i])){    # otherwise use existing ID             trackN<-trackN+1             trackID[i]<-trackN           }           age[i]<-1           dormancy[i]<-0           nearEdge[i]=checkEdge(rawD@polygons[[i]],edgeDist,minCoord,maxCoord)       }else{           tmp<-which(track[i,]==T)
         delta<-dorm[i,tmp]/(-1*maxArea)+1           ifelse(delta>1,dormancy[i]<-(delta-1),dormancy[i]<-0)           age[i]<-age[tmp]+delta           trackID[i]<-trackID[tmp]           nearEdge[i]=checkEdge(rawD@polygons[[i]],edgeDist,minCoord,maxCoord)       }    }    out<-data.frame(cbind(rawD@data,age,survives,dormancy,trackID,nearEdge))    out=out[,c("quad","year","SP_ID","OBJECTID","species","seedling","area","x","y",      "age","survives","dormancy","trackID","nearEdge")]    #write to output    if(firstQuad==T){        write.table(out,outfile,row.names=F,sep=",")        firstQuad=F    }else{       write.table(out,outfile,row.names=F,col.names=F,sep=",",append=T)    } # end if  } # end if length(yrFiles)  } #next quad
warnings()
YrFiles
quadFiles
quad
rawDir
bufDir
yrFiles
rawD
rawD@data$year
infile
nchar(infile)-3
infile
nchar(infile)-5
test = as.numeric(substr(infile, nchar(infile-5), nchar(infile-3)))
test=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))
test
test = as.character(quad)
test
tmp
 tmp=sub("-","_",yrFiles[yrI])
tmp
rawD@data
# This script tracks the identity of polygons in quadrats over time# It assumes polygon holes are correctly flagged# Change handling of missing vs. dormant yrs ???maxDorm=2maxArea=10000 # 1 m^2edgeDist=5minCoord=0maxCoord=100#sppShapes="h://idahochart//lifetables//polys//Species//Artemisia tripartita/"sppShapes = "/Volumes/adler0/idahochart/lifetables/polys/Species/Artemisia tripartita/"#sppBuffers="h://idahochart//lifetables//polys//Species//Artemisia tripartita buf5//"sppBuffers="/Volumes/adler0/idahochart/lifetables/polys/Species/Artemisia tripartita buf5/"#outfile="h://HarmonyData//IPM//ARTR_buf5_dorm2.csv"outfile = "/Users/Harmony/Documents/ipm/ARTR/Data/"#genetFile="h://HarmonyData//IPM//ARTR//AssignGenets//assign_genetsARTR.csv"genetFile = "/Users/Harmony/Documents/ipm/ARTR/AssignGenets/assign_genetsARTR.csv"library(maptools)library(sp)library(gpclib)#---------------------------------------------------------getOverlap=function(x,y){# function to calculate overlap between 2
 polygons# x and y are SpatialPolygons lists of length 1 (1 feature)   N1=length(x@Polygons)   N2=length(y@Polygons)   sumArea=0   for(ii in 1:N1){     for(jj in 1:N2){        p1=x@Polygons[[ii]]@coords        p2=y@Polygons[[jj]]@coords        hole1=ifelse(x@Polygons[[ii]]@hole==T,-1,1)        hole2=ifelse(y@Polygons[[jj]]@hole==T,-1,1)        p1=as(p1,"gpc.poly")        p2=as(p2,"gpc.poly")        # intersect polygons        tmp=intersect(p1,p2)        sumArea=sumArea+area.poly(tmp)*hole1*hole2     } # next jj   } # next ii   sumArea}#---------------------------------------------------------checkEdge=function(x,edgeDist,minCoord,maxCoord){# check whether polygon is close to quadrat edge# x is a SpatialPolygons list object of length 1 (1 feature)   N1=length(x@Polygons)   out=F   ii=1   while(ii<=N1 & out==F){        p1=x@Polygons[[ii]]@coords        if(min(p1)<=(minCoord+edgeDist) |  max(p1)>=(maxCoord-edgeDist)) out=T        ii=ii+1   } # next ii   out}#------------------
---------------------------------------yr1genets=read.csv(genetFile)yr1genets=yr1genets[,c("quad","year","SP_ID","GenID")]#loop through quadratsquadFiles=list.files(path=sppShapes,pattern="q*")firstQuad=Tfor(qI in 1:length(quadFiles)){  quad=quadFiles[qI]  rawDir=paste(sppShapes,quad,sep="")  bufDir=paste(sppBuffers,quad,sep="")  # load all polygons in the quad into one list of SpatialPolygonsDataFrame  # with a new year attribute  #loop through years in quadrat  yrFiles=list.files(path=rawDir,pattern=".shp")  if(length(yrFiles>0)){    begin=T    for(yrI in 1:length(yrFiles)){      if(begin==T){        #original data        infile=paste(rawDir,"/",yrFiles[yrI],sep="")        rawD=readShapePoly(infile)        rawD@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        rawD@data$quad=as.character(quad)        rawD@data=rawD@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        #buffered data        tmp=sub("-","_",yrFiles[yrI])
     infile=paste(bufDir,"/",tmp,sep="")        bufD=readShapePoly(infile)        bufD@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        bufD@data$quad=as.character(quad)        bufD@data=bufD@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        begin=F      }else{        #original data        infile=paste(rawDir,"/",yrFiles[yrI],sep="")        tmp1=readShapePoly(infile)        tmp1@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        tmp1@data$quad=as.character(quad)        tmp1@data=tmp1@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        ID1=getSpPPolygonsIDSlots(rawD)        ID2=getSpPPolygonsIDSlots(tmp1)        ID2=as.character(as.numeric(ID2)+1+max(as.numeric(ID1)))        tmp2=spChFIDs(tmp1,ID2)        rawD=spRbind(rawD,tmp2)        rm(tmp1,tmp2)        #buffered data        tmp=sub("-","_",yrFiles[yrI])        infile=paste(bufDir,"/",tmp,sep="")        tmp1=readS
hapePoly(infile)        tmp1@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        tmp1@data$quad=as.character(quad)        tmp1@data=tmp1@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        ID1=getSpPPolygonsIDSlots(bufD)        ID2=getSpPPolygonsIDSlots(tmp1)        ID2=as.character(as.numeric(ID2)+1+max(as.numeric(ID1)))        tmp2=spChFIDs(tmp1,ID2)        bufD=spRbind(bufD,tmp2)        rm(tmp1,tmp2)      }  # end if    } # next yrI
# join yr 1 genets    tmp=rawD@data    tmp$key=as.numeric(row.names(rawD@data))    tmp$SP_ID=as.character(tmp$SP_ID)    tmp=merge(tmp,yr1genets,all.x=T)    tmp=tmp[order(tmp$key),]    trackID=tmp$GenID    rm(tmp)
 # create matrix of year lags    if(sum(bufD@data$year!=rawD@data$year)>0) stop("Raw and buffer data do not match")    year=bufD@data$year    dorm<-outer(year,year,"-")    dorm[dorm<1]<-NA    dorm[dorm>(1+maxDorm)]<-NA    dorm<-(dorm-1)*maxArea*-1
# create matrix of centroid distances (for tiebreaker)    xdiff<-outer(rawD@data$x,rawD@data$x,FUN="-")    ydiff<-outer(rawD@data$y,rawD@data$y,FUN="-")    dist<-sqrt(xdiff^2+ydiff^2)    rm(xdiff,ydiff)    # create matrix of polygons overlaps    if(dim(dorm)[1]>1){      overlap=dorm      overlap[is.na(overlap)==F]=-99      for(j in 1:(dim(overlap)[1]-1)){        for(k in (j+1):dim(overlap)[1]){            if(is.na(overlap[k,j])==F){              P1=rawD@polygons[[j]]              P2=bufD@polygons[[k]]              overlap[k,j]=getOverlap(P1,P2)            }        } # next k      } # next j      overlap[overlap==0]=NA    }else{      overlap=0    }
    # assign identities    track<-overlap+dorm    rowMax<-apply(track,1,max,na.rm=T)    rowMax<-matrix(rowMax,dim(track)[1],dim(track)[2])    track[track!=rowMax]<-NA    track<-(is.na(track)==F)    track[rawD$seedling=="Y",]<-F    # check for multiple parents    tmp=rowSums(track)    tmp2=which(tmp>1)    if(length(tmp2)>0){      for(j in 1:length(tmp2)){        tmp3=which(track[tmp2[j],]==T)        tmp4=which(dist[tmp2[j],tmp3]==min(dist[tmp2[j],tmp3]))        track[tmp2[j],]=F        track[tmp2[j],tmp3[tmp4]]=T      } # next j    } # end if    if(sum(rowSums(track)>1)) stop("Multiple parents")    isColonist<-ifelse(rowSums(track)==0,1,0)    survives<-1*(colSums(track)>0)    # add to output data table    age<-rep(NA,length(isColonist))    dormancy<-rep(NA,length(isColonist))    # trackID<-rep(NA,length(isColonist))  #assigned above    nearEdge<-rep(NA,length(isColonist))    firstYear<-rep(NA,length(isColonist))    trackN<-max(trackID,na.rm=T)
 for(i in 1:length(isColonist)){       if(isColonist[i]==1)       {           if(is.na(trackID[i])){    # otherwise use existing ID             trackN<-trackN+1             trackID[i]<-trackN           }           age[i]<-1           dormancy[i]<-0           nearEdge[i]=checkEdge(rawD@polygons[[i]],edgeDist,minCoord,maxCoord)       }else{           tmp<-which(track[i,]==T)           delta<-dorm[i,tmp]/(-1*maxArea)+1           ifelse(delta>1,dormancy[i]<-(delta-1),dormancy[i]<-0)           age[i]<-age[tmp]+delta           trackID[i]<-trackID[tmp]           nearEdge[i]=checkEdge(rawD@polygons[[i]],edgeDist,minCoord,maxCoord)       }    }    out<-data.frame(cbind(rawD@data,age,survives,dormancy,trackID,nearEdge))    out=out[,c("quad","year","SP_ID","OBJECTID","species","seedling","area","x","y",      "age","survives","dormancy","trackID","nearEdge")]    #write to output    if(firstQuad==T){        write.table(out,outfile,row.names=F,sep=",")        firstQuad=F    }else{       write.
table(out,outfile,row.names=F,col.names=F,sep=",",append=T)    } # end if  } # end if length(yrFiles)  } #next quad
t
# This script tracks the identity of polygons in quadrats over time# It assumes polygon holes are correctly flagged# Change handling of missing vs. dormant yrs ???maxDorm=2maxArea=10000 # 1 m^2edgeDist=5minCoord=0maxCoord=100#sppShapes="h://idahochart//lifetables//polys//Species//Artemisia tripartita/"sppShapes = "/Volumes/adler0/idahochart/lifetables/polys/Species/Artemisia tripartita/"#sppBuffers="h://idahochart//lifetables//polys//Species//Artemisia tripartita buf5//"sppBuffers="/Volumes/adler0/idahochart/lifetables/polys/Species/Artemisia tripartita buf5/"#outfile="h://HarmonyData//IPM//ARTR_buf5_dorm2.csv"outfile = "/Users/Harmony/Documents/ipm/ARTR/Data/ARTR_buf5_dorm2.csv"#genetFile="h://HarmonyData//IPM//ARTR//AssignGenets//assign_genetsARTR.csv"genetFile = "/Users/Harmony/Documents/ipm/ARTR/AssignGenets/assign_genetsARTR.csv"library(maptools)library(sp)library(gpclib)#---------------------------------------------------------getOverlap=function(x,y){# function to calculat
e overlap between 2 polygons# x and y are SpatialPolygons lists of length 1 (1 feature)   N1=length(x@Polygons)   N2=length(y@Polygons)   sumArea=0   for(ii in 1:N1){     for(jj in 1:N2){        p1=x@Polygons[[ii]]@coords        p2=y@Polygons[[jj]]@coords        hole1=ifelse(x@Polygons[[ii]]@hole==T,-1,1)        hole2=ifelse(y@Polygons[[jj]]@hole==T,-1,1)        p1=as(p1,"gpc.poly")        p2=as(p2,"gpc.poly")        # intersect polygons        tmp=intersect(p1,p2)        sumArea=sumArea+area.poly(tmp)*hole1*hole2     } # next jj   } # next ii   sumArea}#---------------------------------------------------------checkEdge=function(x,edgeDist,minCoord,maxCoord){# check whether polygon is close to quadrat edge# x is a SpatialPolygons list object of length 1 (1 feature)   N1=length(x@Polygons)   out=F   ii=1   while(ii<=N1 & out==F){        p1=x@Polygons[[ii]]@coords        if(min(p1)<=(minCoord+edgeDist) |  max(p1)>=(maxCoord-edgeDist)) out=T        ii=ii+1   } # next ii   out}
#---------------------------------------------------------yr1genets=read.csv(genetFile)yr1genets=yr1genets[,c("quad","year","SP_ID","GenID")]#loop through quadratsquadFiles=list.files(path=sppShapes,pattern="q*")firstQuad=Tfor(qI in 1:length(quadFiles)){  quad=quadFiles[qI]  rawDir=paste(sppShapes,quad,sep="")  bufDir=paste(sppBuffers,quad,sep="")  # load all polygons in the quad into one list of SpatialPolygonsDataFrame  # with a new year attribute  #loop through years in quadrat  yrFiles=list.files(path=rawDir,pattern=".shp")  if(length(yrFiles>0)){    begin=T    for(yrI in 1:length(yrFiles)){      if(begin==T){        #original data        infile=paste(rawDir,"/",yrFiles[yrI],sep="")        rawD=readShapePoly(infile)        rawD@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        rawD@data$quad=as.character(quad)        rawD@data=rawD@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        #buffered data        tmp=sub("-","_
",yrFiles[yrI])        infile=paste(bufDir,"/",tmp,sep="")        bufD=readShapePoly(infile)        bufD@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        bufD@data$quad=as.character(quad)        bufD@data=bufD@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        begin=F      }else{        #original data        infile=paste(rawDir,"/",yrFiles[yrI],sep="")        tmp1=readShapePoly(infile)        tmp1@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        tmp1@data$quad=as.character(quad)        tmp1@data=tmp1@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        ID1=getSpPPolygonsIDSlots(rawD)        ID2=getSpPPolygonsIDSlots(tmp1)        ID2=as.character(as.numeric(ID2)+1+max(as.numeric(ID1)))        tmp2=spChFIDs(tmp1,ID2)        rawD=spRbind(rawD,tmp2)        rm(tmp1,tmp2)        #buffered data        tmp=sub("-","_",yrFiles[yrI])        infile=paste(bufDir,"/",tmp,sep="")
        tmp1=readShapePoly(infile)        tmp1@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        tmp1@data$quad=as.character(quad)        tmp1@data=tmp1@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        ID1=getSpPPolygonsIDSlots(bufD)        ID2=getSpPPolygonsIDSlots(tmp1)        ID2=as.character(as.numeric(ID2)+1+max(as.numeric(ID1)))        tmp2=spChFIDs(tmp1,ID2)        bufD=spRbind(bufD,tmp2)        rm(tmp1,tmp2)      }  # end if    } # next yrI        # join yr 1 genets    tmp=rawD@data    tmp$key=as.numeric(row.names(rawD@data))    tmp$SP_ID=as.character(tmp$SP_ID)    tmp=merge(tmp,yr1genets,all.x=T)    tmp=tmp[order(tmp$key),]    trackID=tmp$GenID    rm(tmp)    # create matrix of year lags    if(sum(bufD@data$year!=rawD@data$year)>0) stop("Raw and buffer data do not match")    year=bufD@data$year    dorm<-outer(year,year,"-")    dorm[dorm<1]<-NA    dorm[dorm>(1+maxDorm)]<-NA    dorm<-(dorm-1)*maxArea*-1
create matrix of centroid distances (for tiebreaker)    xdiff<-outer(rawD@data$x,rawD@data$x,FUN="-")    ydiff<-outer(rawD@data$y,rawD@data$y,FUN="-")    dist<-sqrt(xdiff^2+ydiff^2)    rm(xdiff,ydiff)    # create matrix of polygons overlaps    if(dim(dorm)[1]>1){      overlap=dorm      overlap[is.na(overlap)==F]=-99      for(j in 1:(dim(overlap)[1]-1)){        for(k in (j+1):dim(overlap)[1]){            if(is.na(overlap[k,j])==F){              P1=rawD@polygons[[j]]              P2=bufD@polygons[[k]]              overlap[k,j]=getOverlap(P1,P2)            }        } # next k      } # next j      overlap[overlap==0]=NA    }else{      overlap=0    }        # assign identities    track<-overlap+dorm    rowMax<-apply(track,1,max,na.rm=T)    rowMax<-matrix(rowMax,dim(track)[1],dim(track)[2])    track[track!=rowMax]<-NA    track<-(is.na(track)==F)    track[rawD$seedling=="Y",]<-F    # check for multiple parents    tmp=rowSums(track)    tmp2=which(tmp>1)    if(length(tmp2)>0){
 for(j in 1:length(tmp2)){        tmp3=which(track[tmp2[j],]==T)        tmp4=which(dist[tmp2[j],tmp3]==min(dist[tmp2[j],tmp3]))        track[tmp2[j],]=F        track[tmp2[j],tmp3[tmp4]]=T      } # next j    } # end if    if(sum(rowSums(track)>1)) stop("Multiple parents")    isColonist<-ifelse(rowSums(track)==0,1,0)    survives<-1*(colSums(track)>0)    # add to output data table    age<-rep(NA,length(isColonist))    dormancy<-rep(NA,length(isColonist))    # trackID<-rep(NA,length(isColonist))  #assigned above    nearEdge<-rep(NA,length(isColonist))    firstYear<-rep(NA,length(isColonist))    trackN<-max(trackID,na.rm=T)        for(i in 1:length(isColonist)){       if(isColonist[i]==1)       {           if(is.na(trackID[i])){    # otherwise use existing ID             trackN<-trackN+1             trackID[i]<-trackN           }           age[i]<-1           dormancy[i]<-0           nearEdge[i]=checkEdge(rawD@polygons[[i]],edgeDist,minCoord,maxCoord)       }else{           tmp<-whi
ch(track[i,]==T)           delta<-dorm[i,tmp]/(-1*maxArea)+1           ifelse(delta>1,dormancy[i]<-(delta-1),dormancy[i]<-0)           age[i]<-age[tmp]+delta           trackID[i]<-trackID[tmp]           nearEdge[i]=checkEdge(rawD@polygons[[i]],edgeDist,minCoord,maxCoord)       }    }    out<-data.frame(cbind(rawD@data,age,survives,dormancy,trackID,nearEdge))    out=out[,c("quad","year","SP_ID","OBJECTID","species","seedling","area","x","y",      "age","survives","dormancy","trackID","nearEdge")]    #write to output    if(firstQuad==T){        write.table(out,outfile,row.names=F,sep=",")        firstQuad=F    }else{       write.table(out,outfile,row.names=F,col.names=F,sep=",",append=T)    } # end if  } # end if length(yrFiles)  } #next quad
a = matrix(c(1,S, 0,1),2,2)
a = matrix(c(1,0, 0,1),2,2)
a
a = matrix(c(1,2, 0,1),2,2)
a
a = matrix(c(1,1, 0,1),2,2)
a
b = matrix(c(1,2, 0,1),2,2)
b
a
a%*%b
library(MASS)
?stepAIC
v=c(1:100) #the raw size distributionlmaxSize=log(100)lv = seq(lmaxSize/100, lmaxSize, lmaxSize/100)mu=lv # this says we expect log sizes not to change (no growth)sigma=2 # standard deviation on log scale
v=c(1:100) #the raw size distribution
v=c(1,100) #the raw size distribution
v=c(1:100) #the raw size distribution
v = c(1, 1:100)
v
v=c(1, 1:100) #the raw size distributionlmaxSize=log(100)lv = seq(lmaxSize/100, lmaxSize, lmaxSize/100)
v
lv
mu=lv # this says we expect log sizes not to change (no growth)sigma=2 # standard deviation on log scale
mu = lv
sigma=2
v=c(1:100) #the raw size distributionlmaxSize=log(100)lv = seq(lmaxSize/100, lmaxSize, lmaxSize/100)mu=lv # this says we expect log sizes not to change (no growth)sigma=2 # standard deviation on log scale
mu
sigma
out=dnorm(v,exp(mu[50]),exp(sigma))#
h=v[2]-v[1]#
sum(out)*h  #the integral--fishy that it is so close to 1#
plot(out)
sum(out)*h
h
v
length(v)
rm(v)
v=c(1:100)  #the raw size distribution
v
h=v[2]-v[1]
sum(out)*h  #the integral--fishy that it is so close to 1
plot(out)
sum(out*h)  #the integral--fishy that it is so close to 1
out=dlnorm(v,mu[50],sigma)#
h=v[2]-v[1]#
sum(out)*h # the integral#
plot(out)
lv=seq(lmaxSize/100,lmaxSize,lmaxSize/100) # here's a logged version of #
the size distribution#
out=dnorm(lv,mu[50],sigma)#
h=lv[2]-lv[1]#
sum(out)*h  # note that the integral is within rounding error (?) of #
Option 2#
plot(lv,out)  # hard to compare this plot to Option 2, since the x-axis #
is so different
# Option 1: Here's how I think you do it:#
out=dnorm(v,exp(mu[50]),exp(sigma))#
h=v[2]-v[1]#
sum(out)*h  #the integral--fishy that it is so close to 1#
plot(out)
# This script tracks the identity of polygons in quadrats over time# It assumes polygon holes are correctly flagged# Change handling of missing vs. dormant yrs ???maxDorm=2maxArea=10000 # 1 m^2edgeDist=5minCoord=0maxCoord=100sppShapes="/Volumes/adler100/idahochart/lifetables/polys/Species/Poa secunda/"sppBuffers="/Volumes/adler100/idahochart/lifetables/polys/Species/Poa secunda buf5/"outfile="/Users/Harmony/Documents/ipm/SpeciesData/POSE_buf5_dorm2.csv"genetFile="/Users/Harmony/Documents/ipm/SpeciesData/POSEassign_genets.csv"library(maptools)library(sp)library(gpclib)#---------------------------------------------------------getOverlap=function(x,y){# function to calculate overlap between 2 polygons# x and y are SpatialPolygons lists of length 1 (1 feature)   N1=length(x@Polygons)   N2=length(y@Polygons)   sumArea=0   for(ii in 1:N1){     for(jj in 1:N2){        p1=x@Polygons[[ii]]@coords        p2=y@Polygons[[jj]]@coords        hole1=ifelse(x@Polygons[[ii]]@hole==T,-1,1)
 hole2=ifelse(y@Polygons[[jj]]@hole==T,-1,1)        p1=as(p1,"gpc.poly")        p2=as(p2,"gpc.poly")        # intersect polygons        tmp=intersect(p1,p2)        sumArea=sumArea+area.poly(tmp)*hole1*hole2     } # next jj   } # next ii   sumArea}#---------------------------------------------------------checkEdge=function(x,edgeDist,minCoord,maxCoord){# check whether polygon is close to quadrat edge# x is a SpatialPolygons list object of length 1 (1 feature)   N1=length(x@Polygons)   out=F   ii=1   while(ii<=N1 & out==F){        p1=x@Polygons[[ii]]@coords        if(min(p1)<=(minCoord+edgeDist) |  max(p1)>=(maxCoord-edgeDist)) out=T        ii=ii+1   } # next ii   out}#---------------------------------------------------------dist2edge=function(x,edgeDist,minCoord,maxCoord){# calculate distance from polygons to nearest quadrat edge# x is a SpatialPolygons list object of length 1 (1 feature)   N1=length(x@Polygons)   minDist=rep(NA,N1)   allEdge=rep(NA,N1)   ii=1   for(ii in 1:N1
){        p1=x@Polygons[[ii]]@coords        minDist[ii]=min(c((min(p1)-minCoord),(maxCoord-max(p1))))        tmp1=colSums((p1-minCoord)>5);tmp2=colSums((maxCoord-p1)>5)        allEdge[ii]=ifelse(sum(c(tmp1,tmp2)==0)>0,1,0)   } # next ii   out=c(min(minDist),min(allEdge))   out}#---------------------------------------------------------yr1genets=read.csv(genetFile)yr1genets=yr1genets[,c("quad","year","SP_ID","GenID")]#loop through quadratsquadFiles=list.files(path=sppShapes,pattern="q*")firstQuad=Tfor(qI in 1:length(quadFiles)){  quad=quadFiles[qI]  rawDir=paste(sppShapes,quad,sep="")  bufDir=paste(sppBuffers,quad,sep="")  # load all polygons in the quad into one list of SpatialPolygonsDataFrame  # with a new year attribute  #loop through years in quadrat  yrFiles=list.files(path=rawDir,pattern=".shp")  if(length(yrFiles>0)){    begin=T    for(yrI in 1:length(yrFiles)){      if(begin==T){        #original data        infile=paste(rawDir,"/",yrFiles[yrI],sep="")        rawD=readSh
apePoly(infile)        rawD@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        rawD@data$quad=as.character(quad)        rawD@data=rawD@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        #buffered data        tmp=sub("-","_",yrFiles[yrI])        infile=paste(bufDir,"/",tmp,sep="")        bufD=readShapePoly(infile)        bufD@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        bufD@data$quad=as.character(quad)        bufD@data=bufD@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        begin=F      }else{        #original data        infile=paste(rawDir,"/",yrFiles[yrI],sep="")        tmp1=readShapePoly(infile)        tmp1@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        tmp1@data$quad=as.character(quad)        tmp1@data=tmp1@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        ID1=getSpPPolygonsIDSlots(rawD)
ID2=getSpPPolygonsIDSlots(tmp1)        ID2=as.character(as.numeric(ID2)+1+max(as.numeric(ID1)))        tmp2=spChFIDs(tmp1,ID2)        rawD=spRbind(rawD,tmp2)        rm(tmp1,tmp2)        #buffered data        tmp=sub("-","_",yrFiles[yrI])        infile=paste(bufDir,"/",tmp,sep="")        tmp1=readShapePoly(infile)        tmp1@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        tmp1@data$quad=as.character(quad)        tmp1@data=tmp1@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        ID1=getSpPPolygonsIDSlots(bufD)        ID2=getSpPPolygonsIDSlots(tmp1)        ID2=as.character(as.numeric(ID2)+1+max(as.numeric(ID1)))        tmp2=spChFIDs(tmp1,ID2)        bufD=spRbind(bufD,tmp2)        rm(tmp1,tmp2)      }  # end if    } # next yrI        # join yr 1 genets    tmp=rawD@data    tmp$key=as.numeric(row.names(rawD@data))    tmp$SP_ID=as.character(tmp$SP_ID)    tmp=merge(tmp,yr1genets,all.x=T)    tmp=tmp[order(tmp$key),]    trackID=
tmp$GenID    rm(tmp)    # create matrix of year lags    if(sum(bufD@data$year!=rawD@data$year)>0) stop("Raw and buffer data do not match")    year=bufD@data$year    dorm<-outer(year,year,"-")    dorm[dorm<1]<-NA    dorm[dorm>(1+maxDorm)]<-NA    dorm<-(dorm-1)*maxArea*-1    # create matrix of centroid distances (for tiebreaker)    xdiff<-outer(rawD@data$x,rawD@data$x,FUN="-")    ydiff<-outer(rawD@data$y,rawD@data$y,FUN="-")    dist<-sqrt(xdiff^2+ydiff^2)    rm(xdiff,ydiff)    # create matrix of polygons overlaps    if(dim(dorm)[1]>1){      overlap=dorm      overlap[is.na(overlap)==F]=-99      for(j in 1:(dim(overlap)[1]-1)){        for(k in (j+1):dim(overlap)[1]){            if(is.na(overlap[k,j])==F){              P1=rawD@polygons[[j]]              P2=bufD@polygons[[k]]              overlap[k,j]=getOverlap(P1,P2)            }        } # next k      } # next j      overlap[overlap==0]=NA    }else{      overlap=0    }        # assign identities    track<-overlap+dorm    ro
wMax<-apply(track,1,max,na.rm=T)    rowMax<-matrix(rowMax,dim(track)[1],dim(track)[2])    track[track!=rowMax]<-NA    track<-(is.na(track)==F)    track[rawD$seedling=="Y",]<-F    # check for multiple parents    tmp=rowSums(track)    tmp2=which(tmp>1)    if(length(tmp2)>0){      for(j in 1:length(tmp2)){        tmp3=which(track[tmp2[j],]==T)        tmp4=which(dist[tmp2[j],tmp3]==min(dist[tmp2[j],tmp3]))        track[tmp2[j],]=F        track[tmp2[j],tmp3[tmp4]]=T      } # next j    } # end if    if(sum(rowSums(track)>1)) stop("Multiple parents")    isColonist<-ifelse(rowSums(track)==0,1,0)    survives<-1*(colSums(track)>0)    # add to output data table    age<-rep(NA,length(isColonist))    dormancy<-rep(NA,length(isColonist))    # trackID<-rep(NA,length(isColonist))  #assigned above    #nearEdge<-rep(NA,length(isColonist))    distEdgeMin<-rep(NA,length(isColonist))    allEdge<-rep(NA,length(isColonist))    firstYear<-rep(NA,length(isColonist))    trackN<-max(trackID,na.rm=T)
   for(i in 1:length(isColonist)){       if(isColonist[i]==1)       {           if(is.na(trackID[i])){    # otherwise use existing ID             trackN<-trackN+1             trackID[i]<-trackN           }           age[i]<-1           dormancy[i]<-0           #nearEdge[i]=checkEdge(rawD@polygons[[i]],edgeDist,minCoord,maxCoord)           tmp=dist2edge(rawD@polygons[[i]],edgeDist,minCoord,maxCoord)           distEdgeMin[i]=tmp[1];allEdge[i]=tmp[2]       }else{           tmp<-which(track[i,]==T)           delta<-dorm[i,tmp]/(-1*maxArea)+1           ifelse(delta>1,dormancy[i]<-(delta-1),dormancy[i]<-0)           age[i]<-age[tmp]+delta           trackID[i]<-trackID[tmp]           #nearEdge[i]=checkEdge(rawD@polygons[[i]],edgeDist,minCoord,maxCoord)           tmp=dist2edge(rawD@polygons[[i]],edgeDist,minCoord,maxCoord)           distEdgeMin[i]=tmp[1];allEdge[i]=tmp[2]       }    }    out<-data.frame(cbind(rawD@data,age,survives,dormancy,trackID,distEdgeMin,allEdge))    out=out[,c("quad"
,"year","SP_ID","OBJECTID","species","seedling","area","x","y",      "age","survives","dormancy","trackID","distEdgeMin","allEdge")]    #write to output    if(firstQuad==T){        write.table(out,outfile,row.names=F,sep=",")        firstQuad=F    }else{       write.table(out,outfile,row.names=F,col.names=F,sep=",",append=T)    } # end if    print(paste("Finished",quad,sep=" "))    flush.console()  } # end if length(yrFiles)  } #next quad
warnings()
yr1genets = rea.csv(genetFile)
yr1genets = read.csv(genetFile)
# This script tracks the identity of polygons in quadrats over time# It assumes polygon holes are correctly flagged# Change handling of missing vs. dormant yrs ???maxDorm=2maxArea=10000 # 1 m^2edgeDist=5minCoord=0maxCoord=100sppShapes="/Volumes/adler100/idahochart/lifetables/polys/Species/Poa secunda/"sppBuffers="/Volumes/adler100/idahochart/lifetables/polys/Species/Poa secunda buf5/"outfile="/Users/Harmony/Documents/ipm/SpeciesData/POSE/POSE_buf5_dorm2.csv"genetFile="/Users/Harmony/Documents/ipm/SpeciesData/POSE/POSEassign_genets.csv"library(maptools)library(sp)library(gpclib)#---------------------------------------------------------getOverlap=function(x,y){# function to calculate overlap between 2 polygons# x and y are SpatialPolygons lists of length 1 (1 feature)   N1=length(x@Polygons)   N2=length(y@Polygons)   sumArea=0   for(ii in 1:N1){     for(jj in 1:N2){        p1=x@Polygons[[ii]]@coords        p2=y@Polygons[[jj]]@coords        hole1=ifelse(x@Polygons[[ii]]@hole==T,-1,
1)        hole2=ifelse(y@Polygons[[jj]]@hole==T,-1,1)        p1=as(p1,"gpc.poly")        p2=as(p2,"gpc.poly")        # intersect polygons        tmp=intersect(p1,p2)        sumArea=sumArea+area.poly(tmp)*hole1*hole2     } # next jj   } # next ii   sumArea}#---------------------------------------------------------checkEdge=function(x,edgeDist,minCoord,maxCoord){# check whether polygon is close to quadrat edge# x is a SpatialPolygons list object of length 1 (1 feature)   N1=length(x@Polygons)   out=F   ii=1   while(ii<=N1 & out==F){        p1=x@Polygons[[ii]]@coords        if(min(p1)<=(minCoord+edgeDist) |  max(p1)>=(maxCoord-edgeDist)) out=T        ii=ii+1   } # next ii   out}#---------------------------------------------------------dist2edge=function(x,edgeDist,minCoord,maxCoord){# calculate distance from polygons to nearest quadrat edge# x is a SpatialPolygons list object of length 1 (1 feature)   N1=length(x@Polygons)   minDist=rep(NA,N1)   allEdge=rep(NA,N1)   ii=1   for(
ii in 1:N1){        p1=x@Polygons[[ii]]@coords        minDist[ii]=min(c((min(p1)-minCoord),(maxCoord-max(p1))))        tmp1=colSums((p1-minCoord)>5);tmp2=colSums((maxCoord-p1)>5)        allEdge[ii]=ifelse(sum(c(tmp1,tmp2)==0)>0,1,0)   } # next ii   out=c(min(minDist),min(allEdge))   out}#---------------------------------------------------------yr1genets=read.csv(genetFile)yr1genets=yr1genets[,c("quad","year","SP_ID","GenID")]#loop through quadratsquadFiles=list.files(path=sppShapes,pattern="q*")firstQuad=Tfor(qI in 1:length(quadFiles)){  quad=quadFiles[qI]  rawDir=paste(sppShapes,quad,sep="")  bufDir=paste(sppBuffers,quad,sep="")  # load all polygons in the quad into one list of SpatialPolygonsDataFrame  # with a new year attribute  #loop through years in quadrat  yrFiles=list.files(path=rawDir,pattern=".shp")  if(length(yrFiles>0)){    begin=T    for(yrI in 1:length(yrFiles)){      if(begin==T){        #original data        infile=paste(rawDir,"/",yrFiles[yrI],sep="")        r
awD=readShapePoly(infile)        rawD@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        rawD@data$quad=as.character(quad)        rawD@data=rawD@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        #buffered data        tmp=sub("-","_",yrFiles[yrI])        infile=paste(bufDir,"/",tmp,sep="")        bufD=readShapePoly(infile)        bufD@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        bufD@data$quad=as.character(quad)        bufD@data=bufD@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        begin=F      }else{        #original data        infile=paste(rawDir,"/",yrFiles[yrI],sep="")        tmp1=readShapePoly(infile)        tmp1@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        tmp1@data$quad=as.character(quad)        tmp1@data=tmp1@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        ID1=getSpPPolygonsIDSlots(rawD
)        ID2=getSpPPolygonsIDSlots(tmp1)        ID2=as.character(as.numeric(ID2)+1+max(as.numeric(ID1)))        tmp2=spChFIDs(tmp1,ID2)        rawD=spRbind(rawD,tmp2)        rm(tmp1,tmp2)        #buffered data        tmp=sub("-","_",yrFiles[yrI])        infile=paste(bufDir,"/",tmp,sep="")        tmp1=readShapePoly(infile)        tmp1@data$year=as.numeric(substr(infile,nchar(infile)-5,nchar(infile)-3))        tmp1@data$quad=as.character(quad)        tmp1@data=tmp1@data[,c("SP_ID","area","OBJECTID","species","seedling","x","y","year","quad")]        ID1=getSpPPolygonsIDSlots(bufD)        ID2=getSpPPolygonsIDSlots(tmp1)        ID2=as.character(as.numeric(ID2)+1+max(as.numeric(ID1)))        tmp2=spChFIDs(tmp1,ID2)        bufD=spRbind(bufD,tmp2)        rm(tmp1,tmp2)      }  # end if    } # next yrI        # join yr 1 genets    tmp=rawD@data    tmp$key=as.numeric(row.names(rawD@data))    tmp$SP_ID=as.character(tmp$SP_ID)    tmp=merge(tmp,yr1genets,all.x=T)    tmp=tmp[order(tmp$key),]
  trackID=tmp$GenID    rm(tmp)    # create matrix of year lags    if(sum(bufD@data$year!=rawD@data$year)>0) stop("Raw and buffer data do not match")    year=bufD@data$year    dorm<-outer(year,year,"-")    dorm[dorm<1]<-NA    dorm[dorm>(1+maxDorm)]<-NA    dorm<-(dorm-1)*maxArea*-1    # create matrix of centroid distances (for tiebreaker)    xdiff<-outer(rawD@data$x,rawD@data$x,FUN="-")    ydiff<-outer(rawD@data$y,rawD@data$y,FUN="-")    dist<-sqrt(xdiff^2+ydiff^2)    rm(xdiff,ydiff)    # create matrix of polygons overlaps    if(dim(dorm)[1]>1){      overlap=dorm      overlap[is.na(overlap)==F]=-99      for(j in 1:(dim(overlap)[1]-1)){        for(k in (j+1):dim(overlap)[1]){            if(is.na(overlap[k,j])==F){              P1=rawD@polygons[[j]]              P2=bufD@polygons[[k]]              overlap[k,j]=getOverlap(P1,P2)            }        } # next k      } # next j      overlap[overlap==0]=NA    }else{      overlap=0    }        # assign identities    track<-overlap+d
orm    rowMax<-apply(track,1,max,na.rm=T)    rowMax<-matrix(rowMax,dim(track)[1],dim(track)[2])    track[track!=rowMax]<-NA    track<-(is.na(track)==F)    track[rawD$seedling=="Y",]<-F    # check for multiple parents    tmp=rowSums(track)    tmp2=which(tmp>1)    if(length(tmp2)>0){      for(j in 1:length(tmp2)){        tmp3=which(track[tmp2[j],]==T)        tmp4=which(dist[tmp2[j],tmp3]==min(dist[tmp2[j],tmp3]))        track[tmp2[j],]=F        track[tmp2[j],tmp3[tmp4]]=T      } # next j    } # end if    if(sum(rowSums(track)>1)) stop("Multiple parents")    isColonist<-ifelse(rowSums(track)==0,1,0)    survives<-1*(colSums(track)>0)    # add to output data table    age<-rep(NA,length(isColonist))    dormancy<-rep(NA,length(isColonist))    # trackID<-rep(NA,length(isColonist))  #assigned above    #nearEdge<-rep(NA,length(isColonist))    distEdgeMin<-rep(NA,length(isColonist))    allEdge<-rep(NA,length(isColonist))    firstYear<-rep(NA,length(isColonist))    trackN<-max(trackID,na.rm
=T)        for(i in 1:length(isColonist)){       if(isColonist[i]==1)       {           if(is.na(trackID[i])){    # otherwise use existing ID             trackN<-trackN+1             trackID[i]<-trackN           }           age[i]<-1           dormancy[i]<-0           #nearEdge[i]=checkEdge(rawD@polygons[[i]],edgeDist,minCoord,maxCoord)           tmp=dist2edge(rawD@polygons[[i]],edgeDist,minCoord,maxCoord)           distEdgeMin[i]=tmp[1];allEdge[i]=tmp[2]       }else{           tmp<-which(track[i,]==T)           delta<-dorm[i,tmp]/(-1*maxArea)+1           ifelse(delta>1,dormancy[i]<-(delta-1),dormancy[i]<-0)           age[i]<-age[tmp]+delta           trackID[i]<-trackID[tmp]           #nearEdge[i]=checkEdge(rawD@polygons[[i]],edgeDist,minCoord,maxCoord)           tmp=dist2edge(rawD@polygons[[i]],edgeDist,minCoord,maxCoord)           distEdgeMin[i]=tmp[1];allEdge[i]=tmp[2]       }    }    out<-data.frame(cbind(rawD@data,age,survives,dormancy,trackID,distEdgeMin,allEdge))    out=out
[,c("quad","year","SP_ID","OBJECTID","species","seedling","area","x","y",      "age","survives","dormancy","trackID","distEdgeMin","allEdge")]    #write to output    if(firstQuad==T){        write.table(out,outfile,row.names=F,sep=",")        firstQuad=F    }else{       write.table(out,outfile,row.names=F,col.names=F,sep=",",append=T)    } # end if    print(paste("Finished",quad,sep=" "))    flush.console()  } # end if length(yrFiles)  } #next quad
warnings()
## this script creates the datafiles that are then used to parameterize the IPM functions.## last modified HJD 12-17-08 from PBA's CreateDataFrame.r script. The only changes are the directories.library(boot)## to switch between species, just change the code here.spp = "POSE"directory = paste("/Users/Harmony/Documents/ipm/SpeciesData/", spp, sep = "")setwd(directory)sppFile = paste(spp, "_buf5_dorm2.csv", sep = "")## outfiles for parametersoutfile3 =  "recSize.csv"outfile4 =  "recArea.csv"outfile5 =  "survD.csv"outfile6 =  "growDnoNA.csv"#get quad group datainfile2="/Users/Harmony/Documents/ipm/QuadInfo/quad_info.csv"groupD=read.csv(infile2)# get track dataD=read.csv(sppFile)D=subset(D,year<=57)# get quad inventory & good years for survival and growth (if yr 30 & 31 are present, 30 is a good year)quadInfo=read.csv("/Users/Harmony/Documents/ipm/QuadInfo/quad_inventory.csv")quadInfo=stack(quadInfo)names(quadInfo)=c("year","quad")quadInfo=subset(quadInfo,is.na(year)==F)tmp=quadInfotmp$year=tmp$year-1goodRecords=merge(quadInfo,tmp)goodRecords=goodRecords[order(goodRecords$quad,goodRecords$year),]goodRecords=goodRecords[,c("quad","year")]# aggregate plants (polygons) to genet scale------------------------------------sizeD=aggregate(cbind(D[,c("area","survives")]),    by=list("quad"=D$quad,"year"=D$year,"trackID"=D$trackID),FUN=sum)sizeD$survives[sizeD$survives>1]<-1tmp=aggregate(cbind(D[,c("age")]), by=list("quad"=D$quad,"year"=D$year,"trackID"=D$trackID),FUN=mean)names(tmp)[4]="age"sizeD=merge(sizeD,tmp)tmp=aggregate(D$distEdgeMin,by=list("quad"=D$quad,"year"=D$year,"trackID"=D$trackID),FUN=min)names(tmp)[4]="distEdgeMin"sizeD=merge(sizeD,tmp)tmp=aggregate(D$allEdge,by=list("quad"=D$quad,"year"=D$year,"trackID"=D$trackID),FUN=min)names(tmp)[4]="allEdge"sizeD=merge(sizeD,tmp)tmp=aggregate(D$seedling=="Y",by=list("quad"=D$quad,"year"=D$year,"trackID"=D$trackID),FUN=min)names(tmp)[4]="seedling"sizeD=merge(sizeD,tmp)sizeD$year=as.numeric(as.character(sizeD$year))   quadList=sort(unique(sizeD$quad))# recruits (new genets) per year ------------------------------------tmpD=subset(sizeD,age==1) ## pulls out all of the plants aged 1, i.e. the recruits.tmpD=subset(tmpD,allEdge==0 | seedling==1)   # remove recruits on edges# index yrs by the year recruits were produced, not establishedtmpD$year = as.numeric(as.character(tmpD$year)) tmpD$year=tmpD$year-1## Get good years only.tmpD = merge(tmpD, goodRecords)tmp = aggregate(tmpD$age, by = list("year" = tmpD$year), FUN = sum)# outputting the recruit size data. tmpD=merge(tmpD,groupD)recSize = tmpDwrite.csv(recSize, outfile3)## getting the number of new recruits per quadrat per year.recruitD=aggregate(tmpD[,c("age","area")],by=list("quad"=tmpD$quad,"year"=tmpD$year),  FUN=sum)names(recruitD)=c("quad", "year", "NRquad", "Rarea")nRecruits = aggregate(recruitD[,c("Rarea", "NRquad")], by = list("year" = recruitD$year), FUN = mean)# subset out just the good years and merge with goodRecordsrecruitD=merge(goodRecords,recruitD,all.x=T)recruitD[is.na(recruitD)]=0  # missing data are zeros## subset out the recruits so that we have a dataframe that's just the "Parents" -- genets older than 1 year.tmpP = subset(sizeD, age > 1)## calculate the total parent area. This caluclation doesn't include the area of recruits.parentD = aggregate(tmpP$area, by=list("quad"=tmpP$quad, "year"= tmpP$year),  FUN = sum)names(parentD)[3]="totParea"                ## merge the recruit data and the parent data together. This should have only the good years and good quadrats## becuase the recruitD data frame has only the good years and quadrats.recruitD = merge(recruitD, parentD)## calculate the number of recruits per area.recArea = recruitD$NRquad/recruitD$totParearecruitD$recArea=recArea## outputting the recArea datarecArea = recruitD[,c("quad", "year", "recArea")]recArea=merge(recArea,groupD)write.csv(recArea, outfile4)   # clean uprm(tmpD)rm(tmpP)# genet survival as a function of size and year------------------------------------survD=merge(goodRecords,sizeD)survParams=data.frame("year"=1,"sintercept"=1,"sarea"=1)## outputting the survD datasurvD=merge(survD,groupD)write.csv(survD, outfile5)  # for surviving genets, growth as a function of size ------------------------------------growD=merge(goodRecords,sizeD)   ## pulls out only the good years that we want.growD=subset(growD,survives==1) # only use genets that survive  (also subset edge genets??)growD=growD[c("quad","year","trackID","area", "age","allEdge","distEdgeMin")]names(growD)[4]="area.t0"# merge in area in next yeartmp=sizeD[,c("quad","year","trackID","area")]names(tmp)[4]="area.t1"tmp$year=tmp$year-1growD=merge(growD,tmp,all.x=T)   # NAs in area.t1 are genets that got "swallowed"growDnoNA = merge(growD,tmp)    # this removes the NAs. Can't use them to estimate growth function.## outputting the growDnoNA datagrowDnoNA=merge(growDnoNA,groupD)write.csv(growDnoNA, outfile6)# quadrat coverquadCov=aggregate(D$area,by=list("quad"=D$quad,"year"=D$year),FUN=sum)names(quadCov)[3]="totCover"write.table(quadCov,"quadratCover.csv",row.names=F,sep=",")
spp
